#' Extract Top Features from Joint NMF W Matrix
#'
#' This function is designed to allow you to extract the top features from each NMF component in your model.
#' It is especially useful for Joint NMF analyses because it gives you the option to pull the top features for each input dataframe,
#' enabling easy downstream enrichment analyses.
#'
#' The primary input is an nmf object from the RcppML::nmf function. You can then specify the number of features in the output, as well
#' as the specific NMF components (default=NULL will return top features from all components). For joint NMF analyses where you'd like
#' the top features separated by data type, use the "filter_dfs" argument. It accepts a list of dataframes, which can be either your raw input data
#' or a dataframe with features as the rownames.
#'
#' @param model NMF object generated by RcppML
#' @param n Number of features from the W matrix to return for each NMF component
#' @param components Allows you to specify NMF components (Ex. 1:3 will return top features for NMF 1, 2, and 3). The default NULL
#' will return features from all components
#' @param filter_dfs Default, NULL, will return the top features. For joint NMF analysis where you may want the top features belonging to
#' a particular data type, include dataframe(s) as a LIST object, with features as rownames. Dataframes can be your input data or any dataframe
#' where relevant features are the rownames. (Ex. filter_dfs=list(tcga_betas, tcga_rna_seq) will return top probes and top genes for each component
#' separately)
#' @return List of vectors with the top n features for each NMF component
#' @importFrom utils head
#' @export

topFeatures <- function(model, n = 300, components = NULL, filter_dfs = NULL) {

  W <- model$W

  # If specific components are requested, subset W
  if (!is.null(components)) {
    if (all(components %in% 1:ncol(W))) {
      W <- W[, components, drop = FALSE]
    } else {
      stop("Invalid component indices specified")
    }
  }

  # Extract top features for each component
  top_features <- list()

  # Handle different filtering scenarios based on number of dataframes
  if (is.null(filter_dfs)) {
    # No filtering - just get top features from W
    for (i in 1:ncol(W)) {
      component_name <- colnames(W)[i]
      if (is.null(component_name)) {
        component_name <- paste0("nmf", i)
      }

      # Sort features by weight in descending order
      sorted_features <- sort(W[, i], decreasing = TRUE)

      # Take top n features
      top_n <-   utils::head(sorted_features, n)
      top_features[[component_name]] <- names(top_n)
    }
  } else if (length(filter_dfs) == 1) {
    # Single dataframe filtering
    filter_features <- rownames(filter_dfs[[1]])
    filter_features <- intersect(filter_features, rownames(W))

    if (length(filter_features) == 0) {
      warning("No features found in filter dataframe that match rownames in W matrix.")
    }

    for (i in 1:ncol(W)) {
      component_name <- colnames(W)[i]
      if (is.null(component_name)) {
        component_name <- paste0("nmf", i)
      }

      # Sort features by weight in descending order
      sorted_features <- sort(W[, i], decreasing = TRUE)

      # Filter by dataframe features
      sorted_features <- sorted_features[names(sorted_features) %in% filter_features]

      # Take top n features
      top_n <-   utils::head(sorted_features, n)
      top_features[[component_name]] <- names(top_n)
    }
  } else {
    # Multiple dataframes - process each separately
    for (df_idx in 1:length(filter_dfs)) {
      df_features <- rownames(filter_dfs[[df_idx]])
      df_features <- intersect(df_features, rownames(W))

      if (length(df_features) == 0) {
        warning(paste0("No features found in filter dataframe ", df_idx, " that match rownames in W matrix."))
        next
      }

      for (i in 1:ncol(W)) {
        component_name <- colnames(W)[i]
        if (is.null(component_name)) {
          component_name <- paste0("nmf", i)
        }

        # Create a dataframe-specific component name
        df_component_name <- paste0(component_name, "_df", df_idx)

        # Filter by current dataframe's features and sort
        sorted_features <- sort(W[df_features, i], decreasing = TRUE)

        # Take top n features
        top_n <-   utils::head(sorted_features, n)
        top_features[[df_component_name]] <- names(top_n)
      }
    }
  }

  return(top_features)
}
